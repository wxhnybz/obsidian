## setup函数
1. setup选项的执行时机
在beforeCreate之前，自动执行
2. 风格特点：
定义数据和函数+return。但是也可以直接写语法糖<script\setpu>

## reactive和ref函数
* 共同作用是为了生成响应式数据，可以在模板上进行更新
* ref函数的内部实现依赖于reactive函数
* ref参数类型支持更好，但是必须通过.value进行访问修改
* ref可以包裹简单数据，也可以包裹复杂数据

## 函数定义
```
(parameters) => {
  // 函数体
}
```
- `parameters`：可选的参数列表，用括号括起来，可以包含零个、一个或多个参数。
- `=>`：箭头符号，表示函数定义的开始。
- `{}`：函数体，包含了要执行的代码块。

## 计算属性
计算属性中不应该有“副作用”，计算属性主要是为了完成计算，根据一个数据计算得到一个新的数据，其他的就是副作用
计算属性应该是只读的，我们可以创造一个新的变量来进行存储计算之后的数据

## Watch函数
作用是侦听一个或多个数据的变化，数据变化时执行回调函数，有两个参数，immediate立即执行和deep深度侦听
immediate参数为true时，在开始的时候watch函数就会执行一次。
默认机制时通过watch监听的ref对象默认时浅层侦听的，直接修改嵌套的对象属性不会触发回调执行，此时需要开启deep选项
![[Pasted image 20231003114126.png]]修改嵌套属性的时候就需要深度侦听，只要有一项属性发生改变，deep就会侦听到，会进行递归遍历，会有性能损耗。
当只需要侦听某一个特定的属性的时候，调用回调函数进行精确侦听。
![[Pasted image 20231003115350.png]]

## 生命周期函数
生命周期函数时可以多次执行的，多次执行时传入的回调会在时机成熟时依次执行
这个用法是为了维护代码，将其他工程师开发的在生命周期中的逻辑 不打乱，自己在额外进行补充。

## 父子通信
#### 父传子
基本思想
1. 父组件中给子组件绑定属性
2. 紫钻见内部通过props选项接收
3. ![[Pasted image 20231003122821.png]]
**setup语法糖下局部组件无需注册直接可以使用**

#### 子传父
![[Pasted image 20231003154640.png]]
子组件emit中的连个参数是事件名称和数据参数，事件名称对应到了父组件的模板中，事件触发对应了父组件中的方法，父组件的方法中传入的参数就是子组件传递的信息。从子组件中的方法，对应到了自定义事件，在对应到父组件的方法。

父传子···defineProps({属性名：类型})
通过const props = defineProps({属性名：类型})
子传父...defineEmits(['这是方法'])

## 模板引用
通过ref获取dom对象和组件
![[Pasted image 20231003155809.png]]
1. 通过条用ref函数生成一个ref对象
2. 通过ref表示绑定ref对象到标签 
组件只有在挂载完毕之后才能访问获得

#### defineExpose（）
默认情况下，在<\script setup>语法糖下组件内部的属性和方法是不开放给父组件进行访问的，可以通过defineExpose编译宏指定哪些属性和方法允许访问，是为了防止我们对其进行错误的修改。
#### 小结
* 获取模板应用的时机是在组件挂载完毕之后
* defineExpose编译宏的作用是显式暴露组件内部的属性和方法。
## project和inject
顶层组件向任意的底层组件传递数据的方法，实现跨组件通信。
顶层组件通过project函数提供数据
底层组件通过inject函数获取数据
* provide('key',data) 
* const msg = inject('key')
想在底层组件中修改顶层组件中的数据，需要同时将顶层组件中的修改方法传递给底层组件。（为什么会有这种规则？因为单向数据流，谁的数据谁负责修改）
