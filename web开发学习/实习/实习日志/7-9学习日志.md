## 软件程序面向群体方面
面向可升级平台用户可以使用一些较新的语法
面向强履约用户需要做低版本的测试，需要详细兼容
一般是适配了最低版本其他版本都可以兼容

## Record创建对象类型
####  `React.ReactNode` 
是 React 中的一个类型，表示可以被渲染的内容，例如字符串、数字、React 元素等
#### 创建对象类型
key和value创建键值对
在 TypeScript 中，`Record<K, T>` 是一个实用的泛型类型，它用于创建一个对象类型，其键（key）是 `K` 类型，而值（value）是 `T` 类型。这里的 `K` 通常是 `string`、`number` 或 `symbol` 类型（即对象的键可以是的类型），而 `T` 可以是任何类型。

`Record` 类型非常适合用于表示那些键是预先已知或受限于特定类型，而值也有统一类型的对象。它提供了一种简洁的方式来声明这种键值对集合的类型。
## React的useMemo
每次重新渲染的时候缓存计算结果
```
const cachedValue = useMemo(calculateValue, dependencies)
```
如果计算速度很快，不会产生什么问题，但是当正在过滤转换的一个大型数组或则会进行一些昂贵的计算，而数据没有改变，那么可能希望跳过这些重复计算，如果todos和tab上次渲染相同，那么像之前将计算函数包装在useMemo中，便可以重用已经计算过的visibleTodos。
这种缓存行为叫做***记忆化***
仅仅是一种优化性能的手段，如果没有它，代码也应该可以进行正常工作。

```
console.time('filter array');  
const visibleTodos = filterTodos(todos, tab);  
console.timeEnd('filter array');
```
计算这个函数执行的时间

## 前端中的硬编码数据
就是写死的数据
（**hard-coding**）是指在软件实现上，将输出或输入的相关参数（例如：路径、输出的形式或格式）直接以常量的方式撰写在源代码中，而非在执行期间由外界指定的设置、资源、资料或格式做出适当回应。一般被认定是种反模式或不完美的实现，因为软件受到输入资料或输出格式的改变就必须修改源代码


## Ts中的类型断言
更加精确第定义变量的类型，从而提高代码的可读性和可维护性。
   ``setPosition(value as PositionType[]);
   就是将value断言确信为一种位置属性数组
在TypeScript中，有两种主要的类型断言语法：
1. 尖括号语法：使用尖括号<>来表示类型断言
`let length: number = (<string>value).length`
2. as语法：使用关键字as来表示类型断言
`let length: number = (value as string).length;`

#### 何时使用类型断言？
类型断言在以下情况下特别有用：
**1. 与第三方库集成：** 当你使用第三方库时，可能会遇到无法推断类型的情况。使用类型断言可以告诉TypeScript库的正确类型。
**2. 处理不完全的类型定义：** 有些库的类型定义不完整或不准确。类型断言可以帮助你处理这些情况，使你的代码更加准确。
**3. 优化类型推断：** 有时TypeScript的类型推断不够精确，导致出现不必要的类型错误。使用类型断言可以明确告诉编译器变量的类型。
**4. 使用as语法更安全：** TypeScript推荐使用as语法来进行类型断言，因为它更具可读性并且不容易与JSX语法混淆。

## React.FC函数组件和React.Component类组件
函数组件的性能比类组件的性能好

## 严格模式
在严格模式下，React将调用我们的某些函数为2次而不是1次，
the reason why
1. 组件将重新渲染一次，以查找由于非纯渲染而引起的错误
2. 组件重新运行effect一次，一查找由于缺少effect清理而引起的错误
3. 组件将被检查是否使用了已经弃用的api
	   - 在由 `<StrictMode>` 包裹的树中，无法选择退出严格模式。这可以确保在 `<StrictMode>` 内的所有组件都经过检查。如果两个团队在一个产品上工作，并且对于这些检查是否有价值存在分歧，他们需要达成共识或将 `<StrictMode>` 下移到树的较低层级。
	   - 

```
<StrictMode>  
<App />  
</StrictMode>
```

#### 用法 
1. 为整个应用启用严格模式 
2. 为应用程序的一部分启用严格模式 
3. 修复在开发过程中通过双重渲染发现的错误 
4. 修复在开发中通过重新运行 Effect 发现的错误 
5. 修复严格模式发出的弃用警告


